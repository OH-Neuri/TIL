## 💡13. 스코프

### ✨ 스코프란?

- 모든 식별자(변수 이름, 함수 이름, 클래스의 이름 등) 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 즉, **식별자가 유효한 범위를 말한다.**
- **스코프 내에서 식별자는 유일**해야 하지만 다**른 스코프에는 같은 이름의 식별자를 사용**할 수 있다.

### 스코프의 종류

- 전역 스코프
  - 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다.
- 지역 스코프
  - 함수 몸체 내부에 변수는 선언하면 지역 스코프를 갖는 지역 변수가 된다.
  - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

### ✨ 스코프의 체인

- 함수를 계층적으로 정의하여 함수 중첩에 의해 스코프가 계층적 구조를 갖는 것을 의미한다. 스코프가 계층적으로 연결된 것을 스코프 체인이라 한다.
- **하위 스코프에서 상위 스코프에 선언한 변수를 참조할 수 있다.** (반대는 불가능)
  - 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 **변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 선언된 변수를 검색**한다.
- 스코프 체인은 물리적인 실체로 존재한다.
  - 자바스크립트 엔진은 코드를 실행하기 전에 **렉시컬 환경**을 생성한다. 변수의 선언이 실행되면 변수 식별자가 렉시컬 환경에 키로 등록되고, 변수 할당이 일어나면 해당하는 값을 변경한다.(undefined → 값 할당)

### 함수 레벨 스코프

- 함수에 의해서 생성되는 지역 스코프
- var 키워드로 선언된 변수는 함수 레벨 스코프를 따른다.

### ✨렉시컬 스코프(정적 스코프)

- 함수의 상위 스코프를 결정하는 2가지 패턴
  - 동적 스코프
    - **함수를 어디서 호출 했는지**에 따라 함수의 상위 스코프를 결정하는 방식
  - 렉시컬 스코프(정적 스코프)
    - **함수를 어디서 정의했는지**에 따라 함수의 상위 스코프를 결정하는 방식
    - 함수 정의가 실행될 때 정적으로 결정된다.

## 💡14. 전역 변수의 문제점

### ✨변수의 생명주기

- 변수는 자신이 선언된 위치에서 생성되고 소멸한다.
  - 전역 변수 : 애플리케이션의 생명 주기와 동일
  - 함수 내부 : 함수 호출시 생성되고 종료하면 소멸
  - 블록 내부 : 블록 안에서 생성되고 종료되면 소멸
- 호이스팅은 스코프 단위로 동작한다. 식별자의 스코프가 생성될 때 같이 생성되고 소멸될때 같이 소멸된다.
  - 식별자는 해당 스코프에서만 유효하고 식별의 스코프가 아닌 곳에서 참조하려고 하면 오류가 난다.
- 그러나 누군가가 메모리 공간을 참조하고 있으면 메모리에 해제되지 않고 확보된 상태로 남아있는다.

### 전역 변수의 문제점

- 변수의 유효범위가 크면 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있다.
- 오랜시간 리소스를 사용하게 된다
- 전역 변수의 검색 속도가 가장 느리다.
  - 스코프 체인 상에서 종점에 존재

### 전역 변수의 사용을 억제하는 방법

- 즉시 실행 함수
- 네임스페이스 객체
- 모듈 패턴
- ES6 모듈

## 💡15. let, const 키워드와 블록 레벨 스코프

### ✨var 키워드로 선언한 변수의 문제점

- 변수 중복 선언 허용(재선언)
- 재할당 O
- 함수 레벨 스코프
- 변수 호이스팅

### ✨let 키워드

- 변수 중복 선언 금지(재선언 X)
- 재할당 O
- 블록 레벨 스코프
- 변수 호이스팅 X
  - 호이스팅이 발생하나 할당 전에 참조할 경우 에러가 발생한다.

### ✨const 키워드

- 변수 중복 선언 금지(재선언 X)
- 재할당 X
- 블록 레벨 스코프
- 변수 호이스팅 X

### var vs let vs const

- ES6를 사용한다면 var 키워드는 사용하지 않는다
- 재할당이 필요한 경우만 let을 쓴다. 이때 변수의 스코흐는 최대한 좁게 만든다
